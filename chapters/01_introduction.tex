\chapter{Introduction}\label{chapter:introduction}
In the age of PCIe Gen 5.0 NVMe SSDs we have storage devices which exceed one million I/O operations per second (IOPS). However, with Linux's standard file I/O API ($\texttt{p}$)$\texttt{read}$ and ($\texttt{p}$)$\texttt{write}$, achieving this level of throughput is not possible. Modern asynchronous I/O libraries, such as $\texttt{libaio}$ and $\texttt{io\_uring}$, have offered improvements by reducing latency, thus reaching closer to the physical limits of the SSD, but these still pay performance penalties by interacting the operating system kernel, like context switching and interrupt handling\cite{storage_api}. Maximising the throughput of an SSD requires circumventing the kernel entirely, which has led to the adoption of user-space drivers such as SPDK's NVMe driver.

With this in mind, why write our own driver when SPDK exists? The SPDK codebase itself is complex and extensive, posing a barrier of entry into understanding its inner workings as well as understanding how to optimise storage I/O paths, with SPDK's $\texttt{hello\_world.c}$\footnote{\url{https://github.com/spdk/spdk/blob/0680c7a27bd3950f0b7abb21effde66d5da7976e/examples/nvme/hello_world/hello_world.c}} example coming in at 511 lines. It is also written in a language where critical errors, such as memory leaks or segmentation faults are easily created in a lapse of judgement.

This thesis posits that it is feasible to develop a driver that achieves comparable performance to SPDK, with a simpled API and less code, while leveraging a memory-safe programming language. Thus we want to offer a platform which simplifies the exploration of NVMe storage performance, such topics like write amplication, as well as write a driver where unsafe code is kept to a minimum. To this end, this thesis will explore the development and evaluation of a user-space storage driver written in Rust, a language that promises memory safety guarantees without any performance downfalls.

In \autoref{chapter:basics} we will go over all the background information relevant to the thesis, having a look at NVMe, device drivers in Linux and the Rust programming language. Then, we will shortly elaborate on some other relevant NVMe driver implementations in \autoref{chapter:related}.
We present the implementation in \autoref{chapter:implementation}. We go over how the driver is initialised and bound to the NVMe device, after which we show how I/O operations are handled.
Finally, we analyse the performance of the driver itself in \autoref{chapter:eval}, looking at its throughput and latency, while also comparing it to the other SPDK and the aforementioned Linux I/O APIs.
